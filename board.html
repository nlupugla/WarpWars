<!DOCTYPE html>
<html>
	<head>
		<title>Hella</title>
		<style type="text/css">
			#board { border: 1px solid blue; position: absolute; top: 0px; left: 0px; }
			#info-box { position: absolute; top: 0px; left: 840px; }
		</style>
	</head>
	<body onload="setup();">
		<canvas id="board" width="810" height="810">This is a canvas! If you're reading this message, please upgrade to a better browser.</canvas>
		<div id="info-box">
			<h2 id="turn-indicator">Turn: WHITE</h2>
			<h4 id="phase-indicator">Queen Phase</h4>
			<button id="phase-button" onclick="endPhase()">End Phase</button>
			<div id="mana-box">
				<h4>MANA:</h4>
				<h5 id="white-mana-indicator">WHITE: 0</h6>
				<h5 id="black-mana-indicator">BLACK: 0</h6>
			</div>
		</div>
		<script type="text/javascript">
			// Canvas setup
			var canvas = document.getElementById('board');
			var ctx = canvas.getContext('2d');
			
			// DOM elements for interface
			var turnIndicator = document.getElementById("turn-indicator");
			var phaseIndicator = document.getElementById("phase-indicator");
			var phaseButton = document.getElementById("phase-button");
			var whiteManaIndicator = document.getElementById("white-mana-indicator");
			var blackManaIndicator = document.getElementById("black-mana-indicator");
			
			// Constants for drawing the board
			var min = 5;
			var max = canvas.getAttribute('width')-5;
			var step = 20;
			var lines = ((max-min)/step)+1;
			
			// Board constants
			var width = lines-1;
			var height = width;
			var PieceTypes = Object.freeze({EMPTY: 0, WARPLING: 1});
			var PieceColors = Object.freeze({WHITE: 0, BLACK: 1, EMPTY: 2});
			var TurnOwnership = Object.freeze({WHITE: 0, BLACK: 1});
			var TurnPhases = Object.freeze({QUEEN_PHASE: 0, KING_PHASE: 1});
			var warplingMovesPerQueenPhase = 2;
			
			// Click state tracking
			var noPreviousClick = true;
			var awaitingTargetClickForPieceMovement = false;
			var firstX = -1;
			var firstY = -1;
			
			// Game state tracking
			var currentTurn = TurnOwnership.WHITE;
			var currentPhase = TurnPhases.QUEEN_PHASE;
			var board = new Array(width);
			var whiteMana = 0;
			var blackMana = 0;
			var currentWarplingMoves = 0;
			
			//make a piece
			function Piece(type, color){
				this.type = type;
				this.color = color;
			}
			
			function setup(){
				createBoard();
				placeStartingWarplings();
				whiteMana = generateMana(PieceColors.WHITE);
				draw();
			}
			
			// create and fill the board with empty spaces
			function createBoard(){
				for(var i = 0; i < width; i++){
					board[i] = new Array(height);
					for(var j = 0; j < height; j++){
						board[i][j] = new Piece(PieceTypes.EMPTY, PieceColors.EMPTY);
					}
				}
			}
			
			// place a starting set of warplings for both players
			function placeStartingWarplings(){
				for(var i = 0; i < width; i++){
					if(i % 2 == 0){
						board[i][0] = new Piece(PieceTypes.WARPLING, PieceColors.BLACK);
						board[i][2] = new Piece(PieceTypes.WARPLING, PieceColors.BLACK);
						board[i][height - 3] = new Piece(PieceTypes.WARPLING, PieceColors.WHITE);
						board[i][height - 1] = new Piece(PieceTypes.WARPLING, PieceColors.WHITE);
					} else {
						board[i][1] = new Piece(PieceTypes.WARPLING, PieceColors.BLACK);
						board[i][height - 2] = new Piece(PieceTypes.WARPLING, PieceColors.WHITE);
					}
				}
			}
			
			// fill all user-facing interface elements
			function updateInterface(){
				if(currentTurn == TurnOwnership.WHITE){
					turnIndicator.innerHTML = "Turn: WHITE";
				} else {
					turnIndicator.innerHTML = "Turn: BLACK";
				}
				if(currentPhase == TurnPhases.QUEEN_PHASE){
					phaseIndicator.innerHTML = "Queen Phase";
					phaseButton.innerHTML = "End Phase";
				} else {
					phaseIndicator.innerHTML = "King Phase";
					phaseButton.innerHTML = "End Turn";
				}
				whiteManaIndicator.innerHTML = "WHITE: " + whiteMana;
				blackManaIndicator.innerHTML = "BLACK: " + blackMana;
			}
			
			// end the current phase, handling all necessary cleanup
			function endPhase(){
				if(currentPhase == TurnPhases.QUEEN_PHASE){
					currentPhase = TurnPhases.KING_PHASE;
				} else {
					currentPhase = TurnPhases.QUEEN_PHASE;
					endTurn();
				}
				
				// update interface
				updateInterface();
			}
			
			// end turn, handling all necessary cleanup
			function endTurn(){
				// flip the turn
				if(currentTurn == TurnOwnership.WHITE){
					currentTurn = TurnOwnership.BLACK;
				} else {
					currentTurn = TurnOwnership.WHITE;
				}
				// reset move counts
				currentWarplingMoves = 0;
				// TODO: end all until-EOT effects here
				
				// generate mana for the start of the coming queen phase
				if(currentTurn == TurnOwnership.WHITE){
					whiteMana = generateMana(PieceColors.WHITE);	
				} else {
					blackMana = generateMana(PieceColors.BLACK)
				}
				
			}
			
			// generates mana for the given player based on adjacent pairs of warplings of the given color
			function generateMana(color){
				totalMana = 0;
				for(var i = 0; i < width; i++){
					for(var j = 0; j < height; j++){
						if((board[i][j].type == PieceTypes.WARPLING) && (board[i][j].color == color)){
							if(i+1 < width){
								if((board[i+1][j].type == PieceTypes.WARPLING) && (board[i+1][j].color == color)){
									totalMana++;
								}
							}
							if(j+1 < height){
								if((board[i][j+1].type == PieceTypes.WARPLING) && (board[i][j+1].color == color)){
									totalMana++;
								}
							}
						}
						
					}
				}
				return totalMana;
			}
			
			// returns the absolute value of input
			function absVal(input){
				if(input < 0){
					input = -input;
				}
				return input;
			}
			
			// converts a canvas coordinate to a board coordinate
			function convertToGridCoord(input){
				input = snapToGridCorner(input)
				input -= min;
				input /= step;
				return input;
			}
			
			// snaps a canvas coordinate to the top-left corner of the enclosing board square 
			function snapToGridCorner(input){
				input -= min;
				input -= (input % step);
				input += min;
				return input;
			}
			
			// converts a board coordinate to the canvas coordinate of the top-left corner of the board square
			function convertToCanvasCoord(input){
				input *= step;
				input += min;
				return input;
			}
			
			// draw a line between two points
			function drawLine(startX, startY, endX, endY){
				ctx.beginPath();
				ctx.moveTo(startX, startY);
				ctx.lineTo(endX, endY);
				ctx.stroke();
			}
			
			// draw a circle; x and y must be coordinates of the top-left of the grid square
			function drawCircle(x, y){
				ctx.beginPath();
				ctx.arc(x+step/2, y+step/2, step*3/8, 0, Math.PI*2);
				ctx.fill();
				ctx.stroke();
			}
			
			// fill a board space with the given color
			function drawSpace(boardX, boardY, color){
				var x = convertToCanvasCoord(boardX);
				var y = convertToCanvasCoord(boardY);
				ctx.fillStyle = color;
				ctx.fillRect(x+1, y+1, step-2, step-2);
			}
			
			// draw a piece in a space
			function drawPiece(boardX, boardY, piece){
				// convert board coords to canvas coords
				var x = convertToCanvasCoord(boardX);
				var y = convertToCanvasCoord(boardY);
				// set the appropriate color
				switch(piece.color){
					case PieceColors.EMPTY: //if the space is empty, there's no piece to draw
						return;
						break;
					case PieceColors.WHITE:
						ctx.strokeStyle = "#000000";
						ctx.fillStyle = "#ffffff";
						break;
					case PieceColors.BLACK:
						ctx.strokeStyle = "#000000";
						ctx.fillStyle = "#000000";
						break;
				}
				// draw the piece
				switch(piece.type){
					case PieceTypes.EMPTY:
						break;
					case PieceTypes.WARPLING:
						drawCircle(x, y);
						break;
				}
			}
			
			// draw the basic grid
			function draw(){
				ctx.fillStyle = "";
				ctx.strokeStyle = "#000000";
				ctx.lineWidth = 2.0;
				
				for(var i = 0; i < lines; i++){
					drawLine(min, min+i*step, max, min+i*step);
					drawLine(min+i*step, min, min+i*step, max);
				}
				
				redraw();
			}
			
			// draw the contents of the board
			function redraw(){
				ctx.lineWidth = 2.0;
				ctx.fillStyle = "#ffffff";
				ctx.strokeStyle = "#000000";
				
				for(var i = 0; i < width; i++){
					for(var j = 0; j < height; j++){
						drawSpace(i, j, "#ffffff");
						if(board[i][j].type != PieceTypes.EMPTY){
							drawPiece(i, j, board[i][j]);
						}
					}
				}
			}
			
			// returns a list of points moveable to by the piece on the given board square
			function getMoveableSpaces(boardX, boardY, piece){
				list = new Array();
				returnList = new Array();
				switch(piece.type){
					// effective default cause, here so we can fail-fast
					case PieceTypes.EMPTY:
						break;
					case PieceTypes.WARPLING:
						if(boardX > 0) list.push([boardX-1, boardY]);
						if(boardX+1 < width) list.push([boardX+1, boardY]);
						if(boardY > 0) list.push([boardX, boardY-1]);
						if(boardY+1 < height) list.push([boardX, boardY+1]);
						break; // redundant, but whatever
				}
				// remove spaces occupied by friendly pieces
				for(var i = 0; i < list.length; i++){
					if(board[list[i][0]][list[i][1]].color != piece.color){
						returnList.push(list[i]);
					}
				}
				return returnList;
			}
			
			// handle clicks
			function handleClick(event){
				// do we need to check that these are inside the board and handle them being outside?
				var x = convertToGridCoord(event.x);
				var y = convertToGridCoord(event.y);

				if(noPreviousClick){
					// can only pieces on your own turn
					if(board[x][y].color == currentTurn){
						firstX = x;
						firstY = y;
						
						// can only move warplings in queen phase a certain number of times
						if(board[x][y].type == PieceTypes.WARPLING){
							if((currentPhase != TurnPhases.QUEEN_PHASE) || (currentWarplingMoves >= warplingMovesPerQueenPhase)){
								return;
							}
						}
						
						noPreviousClick = false;
						awaitingTargetClickForPieceMovement = true;
						
						// paint the selected space
						drawSpace(x, y, "#aaff00");
						drawPiece(x, y, board[x][y]);
						
						// paint all spaces the piece can move to
						moveableSpaces = getMoveableSpaces(x, y, board[x][y]);
						for(var i = 0; i < moveableSpaces.length; i++){
							drawSpace(moveableSpaces[i][0], moveableSpaces[i][1], "#00ff00");
							drawPiece(moveableSpaces[i][0], moveableSpaces[i][1], board[moveableSpaces[i][0]][moveableSpaces[i][1]]);
						}
					}
				} else if(awaitingTargetClickForPieceMovement){
					// check if target space is moveable to by current piece
					if(getMoveableSpaces(firstX, firstY, board[firstX][firstY]).some(function(e){return ((e[0] == x) && (e[1] == y))})){
						// actually move the piece
						board[x][y] = board[firstX][firstY];
						board[firstX][firstY] = new Piece(PieceTypes.EMPTY, PieceColors.EMPTY);
						
						// keep track of warpling moves, flipping the phase if we've hit max
						if(board[x][y].type == PieceTypes.WARPLING){
							currentWarplingMoves++;
							if(currentWarplingMoves == warplingMovesPerQueenPhase){
								endPhase();
							}
						}
					}
					// regardless of legality of the move, reset state and redraw
					noPreviousClick = true;
					awaitingTargetClickForPieceMovement = false;
					firstX = 0;
					firstY = 0;
					redraw();
				}
			}
			
			canvas.addEventListener("click", handleClick, false);
		</script>
	</body>
</html>
