<!DOCTYPE html>
<html>
	<head>
		<title>Game {{ game_id }} || WARP WARS</title>
		<style type="text/css">
			#board { border: 1px solid blue; position: absolute; top: 0px; left: 0px; }
			#info-box { position: absolute; top: 0px; left: 840px; }
		</style>
	</head>
	<body onload=setup()>
		<canvas id="board" width="810" height="810">This is a canvas! If you're reading this message, please upgrade to a better browser.</canvas>
		<div id="info-box">
			<h2 id="game-id">Game ID: {{ game_id }}</h2>
			<h2 id="turn-indicator">Turn: WHITE</h2>
			<h3 id="turn-number-indicator">Turn 1</h3>
			<div id="mana-box">
				<h4>MANA:</h4>
				<h5 id="white-mana-indicator">WHITE: 0</h6>
				<h5 id="black-mana-indicator">BLACK: 0</h6>
			</div>
			<button onclick="makeGetRequest('{{ state }}', updateState)">UPDATE</button>
			
		</div>
		<script type="text/javascript" src="{{ drawing_file }}" ></script>
		<script type="text/javascript">
			// Canvas setup
			var canvas = document.getElementById('board');
			var ctx = canvas.getContext('2d');
			
			// DOM elements for interface
			var turnIndicator = document.getElementById("turn-indicator");
			var turnNumberIndicator = document.getElementById("turn-number-indicator");
			var whiteManaIndicator = document.getElementById("white-mana-indicator");
			var blackManaIndicator = document.getElementById("black-mana-indicator");
			
			// Constants for drawing the board
			var MIN = 5;
			var MAX = canvas.getAttribute('width')-5;
			var STEP = 80;
			var LINES = ((MAX-MIN)/STEP)+1;
			
			// Board constants
			var WIDTH = LINES-1;
			var HEIGHT = WIDTH;
			var PieceTypes = Object.freeze({EMPTY: 0, WARPLING: 1, KING: 2});
			var PieceColors = Object.freeze({WHITE: 0, BLACK: 1, EMPTY: 2});
			var EMPTY_ID = 0;
			var TurnOwnership = Object.freeze({WHITE: 0, BLACK: 1});
			
			// Click state tracking
			var ClickStates = Object.freeze({NO_PREVIOUS_CLICK: 0, AWAITING_CLICK_FOR_MOVEMENT: 1, AWAITING_CLICK_FOR_DEPLOYMENT: 2});
			var clickState = ClickStates.NO_PREVIOUS_CLICK;
			var firstX = -1;
			var firstY = -1;
			
			// Game state tracking
			var currentState = 0;
			var playerColor = {{ player_color }}; // the player playing through this client
			var currentTurn = TurnOwnership.WHITE;
			var currentTurnNumber = 1;
			var board = new Array(WIDTH);
			var whiteMana = 0;
			var blackMana = 0;
			
			// Constructor for a Piece
			function Piece(type, color, id){
				this.type = type;
				this.color = color;
				this.id = id;
			}
			
			// perform initial setup of the canvas
			function setup(){
				createBoard();
				placeStartingWarplings();
				draw();
			}
			
			// create and fill the board with empty spaces
			function createBoard(){
				for(var i = 0; i < WIDTH; i++){
					board[i] = new Array(HEIGHT);
					for(var j = 0; j < HEIGHT; j++){
						board[i][j] = new Piece(PieceTypes.EMPTY, PieceColors.EMPTY, EMPTY_ID);
					}
				}
			}
			
			// place a starting set of warplings for both players
			function placeStartingWarplings(){
				for(var i = 0; i < WIDTH; i++){
					if(i % 2 == 0){
						board[i][0] = new Piece(PieceTypes.WARPLING, PieceColors.BLACK, i*4);
						board[i][2] = new Piece(PieceTypes.WARPLING, PieceColors.BLACK, i*4+1);
						board[i][HEIGHT - 3] = new Piece(PieceTypes.WARPLING, PieceColors.WHITE, i*4+2);
						board[i][HEIGHT - 1] = new Piece(PieceTypes.WARPLING, PieceColors.WHITE, i*4+3);
					} else {
						board[i][1] = new Piece(PieceTypes.WARPLING, PieceColors.BLACK, i*4);
						board[i][HEIGHT - 2] = new Piece(PieceTypes.WARPLING, PieceColors.WHITE, i*4+1);
					}
				}
			}
			
			// fill all user-facing interface elements
			function updateInterface(){
				if(currentTurn == TurnOwnership.WHITE){
					turnIndicator.innerHTML = "Turn: WHITE";
				} else {
					turnIndicator.innerHTML = "Turn: BLACK";
				}
				turnNumberIndicator.innerHTML = "Turn " + currentTurnNumber;
				whiteManaIndicator.innerHTML = "WHITE: " + whiteMana;
				blackManaIndicator.innerHTML = "BLACK: " + blackMana;
			}
			
			// end turn, handling all necessary cleanup
			function endTurn(){
				// flip the turn
				if(currentTurn == TurnOwnership.WHITE){
					currentTurn = TurnOwnership.BLACK;
				} else {
					currentTurn = TurnOwnership.WHITE;
				}
				currentTurnNumber++;
				updateInterface();
			}
			
			// returns a list of points moveable to by the piece on the given board square
			function getMoveableSpaces(boardX, boardY, piece){
				list = new Array();
				returnList = new Array();
				switch(piece.type){
					// effective default cause, here so we can fail-fast
					case PieceTypes.EMPTY:
						break;
					case PieceTypes.WARPLING:
						if(boardX > 0) list.push([boardX-1, boardY]);
						if(boardX+1 < WIDTH) list.push([boardX+1, boardY]);
						if(boardY > 0) list.push([boardX, boardY-1]);
						if(boardY+1 < HEIGHT) list.push([boardX, boardY+1]);
						break; // redundant, but whatever
				}
				// remove spaces occupied by friendly pieces
				for(var i = 0; i < list.length; i++){
					if(board[list[i][0]][list[i][1]].color != piece.color){
						returnList.push(list[i]);
					}
				}
				return returnList;
			}
			
			// handle clicks
			function handleClick(event){
				// do we need to check that these are inside the board and handle them being outside?
				var x = convertToGridCoord(event.x);
				var y = convertToGridCoord(event.y);

				if(clickState == ClickStates.NO_PREVIOUS_CLICK){
					// can only pieces on your own turn
					if(board[x][y].color == currentTurn){
						firstX = x;
						firstY = y;
						
						clickState = ClickStates.AWAITING_CLICK_FOR_MOVEMENT;
						
						// paint the selected space
						drawSpace(x, y, "#aaff00");
						drawPiece(x, y, board[x][y]);
						
						// paint all spaces the piece can move to
						moveableSpaces = getMoveableSpaces(x, y, board[x][y]);
						for(var i = 0; i < moveableSpaces.length; i++){
							drawSpace(moveableSpaces[i][0], moveableSpaces[i][1], "#00ff00");
							drawPiece(moveableSpaces[i][0], moveableSpaces[i][1], board[moveableSpaces[i][0]][moveableSpaces[i][1]]);
						}
					}
				} else if(clickState == ClickStates.AWAITING_CLICK_FOR_MOVEMENT){
					// check if target space is moveable to by current piece
					if(getMoveableSpaces(firstX, firstY, board[firstX][firstY]).some(function(e){return ((e[0] == x) && (e[1] == y))})){
						// actually move the piece
						board[x][y] = board[firstX][firstY];
						board[firstX][firstY] = new Piece(PieceTypes.EMPTY, PieceColors.EMPTY, EMPTY_ID);
						
						makeGetRequest('/update/game/' + game_id + '/move/' + board[x][y].id + '/to/' + x + '/' + y, function(){})
						
						// flip the turn
						endTurn();
					}
					// regardless of legality of the move, reset state and redraw
					clickState = ClickStates.NO_PREVIOUS_CLICK;
					firstX = 0;
					firstY = 0;
					redraw();
				}
			}
			
			canvas.addEventListener("click", handleClick, false);
			
			// check for new state, updating if we've received any
			function updateOnNewState(data){
				if(data['changed']){
					makeGetRequest('{{ state }}', updateState);
				}
			}
			
			// update client-side state with state from the server
			function updateState(new_state){
				// wipe the board, place all the new units
				createBoard();
				for(var i = 0; i < new_state['units'].length; i++){
					unit = new_state['units'][i];
					type = unit['type'];
					color = unit['color'];
					id = unit['ID'];
					board[unit['x']][unit['y']] = new Piece(type, color, id);
				}
				
				// set the current turn and turn number
				currentTurn = new_state['active_color'];
				currentTurnNumber = new_state['turn'];
				
				// TODO: get the mana totals for the players
				
				// TODO: get palette information for both players
				
				// reset click state
				clickState = ClickStates.NO_PREVIOUS_CLICK;
				
				// update the board and interface
				redraw();
				updateInterface();
			}
			
			// make AJAX GET request
			function makeGetRequest(url, callback){
				var request = new XMLHttpRequest();
				request.open('GET', url, true);
				
				request.onload = function(){
					if(request.status >= 200 && request.status < 400) {
						// success
						var data = JSON.parse(request.responseText);
						callback(data);
					} else {
						// We reached our target server, but it returned an error
					}
				};

				request.onerror = function() {
					// There was a connection error of some sort
				};

				request.send();
			}
			
			// var refreshID = window.setInterval(makeGetRequest, 100, '{{ changed }}' + currentState, updateOnNewState);
		</script>
	</body>
</html>